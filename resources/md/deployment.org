** Running Standalone
:PROPERTIES:
:CUSTOM_ID: running-standalone
:END:
To create a standalone executable for your application simply run

#+begin_src sh
clj -Sforce -T:build all
#+end_src

The resulting =jar= can be found in the =target/uberjar= folder. It can
be run as follows:

#+begin_src sh
java -jar <app>.jar
#+end_src

To specify a custom port you need to set the =$PORT= environment
variable, eg:

#+begin_example
export PORT=8080
java -jar <app>.jar
#+end_example

** VPS Deployment
:PROPERTIES:
:CUSTOM_ID: vps-deployment
:END:
Virtual Private Servers (VPS) such as
[[https://www.digitalocean.com/][DigitalOcean]] provide a cheap hosting
option for Clojure applications.

Follow
[[https://www.digitalocean.com/community/tutorials/how-to-create-your-first-digitalocean-droplet-virtual-server][this
guide]] in order to setup your DigitalOcean server. Once the server is
created you can install Ubuntu
[[https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-12-04][as
described here]]. Finally, install Java on your Ubuntu instance by
following [[https://help.ubuntu.com/community/Java][these
instructions]]. The instructions below apply for Ubuntu 15.04 and newer.

The most common approach is to run the =uberjar= and front it using
[[http://wiki.nginx.org/Main][Nginx]].

*** Application deployment
:PROPERTIES:
:CUSTOM_ID: application-deployment
:END:
In this step, we will deploy your application to the server, and make
sure that it is started automatically on boot. We use =systemd= for
this. Create a =deploy= user that will run your application:

#+begin_example
sudo adduser -m deploy
sudo passwd -l deploy
#+end_example

Create a directory for your application on the server such as
=/var/myapp= then upload your application to the server using =scp=:

#+begin_example
$ scp myapp.jar user@<domain>:/var/myapp/
#+end_example

You should now test that you're able to run the application. Connect to
the server using =ssh= and run the application:

#+begin_example
java -jar /var/myapp/myapp.jar
#+end_example

If everything went well, your application now runs locally. The
following command will confirm that the applications runs as expected:

#+begin_example
curl http://127.0.0.1:3000/
#+end_example

Your application should also now be accessible on the server at
=http://<domain>:3000=. If your application is not accessible make sure
that the firewall is configured to allow access to the port. Depending
on your VPS provider, you may need to create an access point for the
port 3000. *
[[https://azure.microsoft.com/en-us/documentation/articles/virtual-machines-set-up-endpoints/][Creating
access point on Azure]] *
[[http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/using-network-security.html#adding-security-group-rule][Creating
access point on Amazon EC2]]

*** systemd start configuration
:PROPERTIES:
:CUSTOM_ID: systemd-start-configuration
:END:
Now, let's stop the application instance and create a =systemd=
configuration to manage its lifecycle, especially taking care that the
application will be launched on server boot. Create the file
=/lib/systemd/system/myapp.service= with the following content:

#+begin_example
[Unit]
Description=My Application
After=network.target

[Service]
WorkingDirectory=/var/myapp
EnvironmentFile=-/var/myapp/env
Environment="DATABASE_URL=jdbc:postgresql://localhost/app?user=app_user&password=secret"
ExecStart=/usr/bin/java -jar /var/myapp/myapp.jar
User=deploy

[Install]
WantedBy=multi-user.target
#+end_example

The =WantedBy== is the target level that this unit is a part of. To find
the default run level for your system run:

#+begin_example
systemctl get-default
#+end_example

Note that by default JVM is fairly aggressive about memory usage. If
you'd like to reduce the amount of memory used then you can add the
following line under the =[Service]= configuration:

#+begin_example
[Service]
...
_JAVA_OPTIONS="-Xmx256m"
ExecStart=/usr/bin/java -jar /var/myapp/myapp.jar
#+end_example

This will limit the maximum amount of memory that the JVM is allowed to
use. Now we can tell =systemd= to start the application everytime the
system reboots with the following commands:

#+begin_example
sudo systemctl daemon-reload
sudo systemctl enable myapp.service
#+end_example

When the system reboots your application will now start and will be
ready to process requests. You may want to test that. Simply reboot your
machine, and check the running processes:

#+begin_example
 ps -ef | grep java
#+end_example

This should return something like the line below. Pay attention to the
=UID= - it should be =deploy=, since running it as =root= would present
a significant security risk.

#+begin_example
deploy     730     1  1 06:45 ?        00:00:42 /usr/bin/java -jar /var/mysite/mysite.jar
#+end_example

*** Fronting with Nginx
:PROPERTIES:
:CUSTOM_ID: fronting-with-nginx
:END:
Install Nginx using the following command:

#+begin_example
$ sudo apt-get install nginx
#+end_example

Next, make a backup of the default configuration in
=/etc/nginx/sites-available/default= and replace it with a custom
configuration file for the application such as:

#+begin_example
server{
  listen 80 default_server;
  listen [::]:80 default_server ipv6only=on;
  server_name localhost mydomain.com www.mydomain.com;

  access_log /var/log/myapp_access.log;
  error_log /var/log/myapp_error.log;
  
  location / {
    proxy_pass http://localhost:3000/;
    proxy_set_header Host $http_host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect  off;
  }
}
#+end_example

Restart Nginx by running:

#+begin_example
sudo service nginx restart
#+end_example

Then test that the application is available at =http://<domain>=.

Optionally, you can configure Nginx to serve static resources for the
application. In order to do that you will need to ensure that all static
resources are served using a common prefix such as =static=. Next,
upload the =resources/public/static= folder from your application to the
server to a location such as =/var/myapp/static= by running the
following command from the project folder:

#+begin_example
scp -r resources/public/static user@<domain>:/var/myapp/static
#+end_example

Now add the following additional configuration option under the =server=
section of the Ngnix configuration above:

#+begin_example
location /static/ {
    alias /var/myapp/static/;
  }
#+end_example

This will cause Nginx to bypass your application for any requests to
=http://<domain>/static= and serve them directly instead.

To enable compression make sure the following settings are present in
your =/etc/nginx/nginx.conf=:

#+begin_example
gzip on;
gzip_disable "msie6";

gzip_vary on;
gzip_proxied any;
gzip_comp_level 6;
gzip_buffers 16 8k;
gzip_http_version 1.1;
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;">
#+end_example

*** Setting up SSL
:PROPERTIES:
:CUSTOM_ID: setting-up-ssl
:END:
If your site has any user authentication then you will also want to use
HTTPS. You will first need to provide a SSL certificate and its key.
We'll call these =cert.crt= and =cert.key= respectively.

**** Setting up SSL Certificate using Let's Encrypt
:PROPERTIES:
:CUSTOM_ID: setting-up-ssl-certificate-using-lets-encrypt
:END:
The easiest way to setup SSL is to use
[[https://certbot.eff.org/][Certbot]] and to follow the instructions on
the site.

Download the installation tool and generate the certificate using the
following commands:

#+begin_example
git clone https://github.com/certbot/certbot
cd certbot
./certbot-auto certonly --email <you@email.com> -d <yoursite.com> -d <www.yoursite.com> --webroot --webroot-path /var/www/html
#+end_example

Optionally, setup a Cron job to automatically update the certificate by
updating crontab by running as =root=:

#+begin_example
su
crontab -e
#+end_example

Add the following line:

#+begin_example
0 0 1,15 * * /path-to-certbot/certbot-auto certonly --keep-until-expiring --email <you@email.com> -d <yoursite.com> -d <www.yoursite.com> --webroot --webroot-path /var/www/html
#+end_example

Alternatively, you could use
[[https://github.com/hlandau/acme][Acmetool]] as a comprehensive
solution for keeping certificates up to date.

We'll generate a stronger DHE parameter instead of using OpenSSL's
defaults, which include a 1024-bit key for the key-exchange:

#+begin_example
cd /etc/ssl/certs
openssl dhparam -out dhparam.pem 4096
#+end_example

There are two options for handling HTTPS connections. You can either
configure the HTTP server in the app itself, or front it with Nginx.
We'll look at both approaches below.

***** Nginx SSL config
:PROPERTIES:
:CUSTOM_ID: nginx-ssl-config
:END:
To use Nginx as your SSL proxy you'll want to update the configuration
in =/etc/nginx/sites-available/default= as follows:

#+begin_example
server {
    listen 80;
    return 301 https://$host$request_uri;
}

server {

    listen 443;
    server_name localhost mydomain.com www.mydomain.com;

    ssl_certificate           /etc/letsencrypt/live/<yoursite.com>/fullchain.pem;
    ssl_certificate_key       /etc/letsencrypt/live/<yoursite.com>/privkey.pem;

    ssl on;
    ssl_prefer_server_ciphers  on;
    ssl_session_timeout        180m;
    ssl_session_cache  builtin:1000  shared:SSL:10m;
    ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'AES256+EECDH:AES256+EDH';
    ssl_dhparam /etc/ssl/certs/dhparam.pem;
    add_header Strict-Transport-Security 'max-age=31536000';

    access_log /var/log/myapp_access.log;
    error_log /var/log/myapp_error.log;

     # If you use websocket over https, add below two lines.
    proxy_set_header Upgrade $http_upgrade; ###
    proxy_set_header Connection "Upgrade";   ###

    location / {

      proxy_set_header        Host $host;
      proxy_set_header        X-Real-IP $remote_addr;
      proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
      proxy_set_header        X-Forwarded-Proto $scheme;

      # Fix the “It appears that your reverse proxy set up is broken" error.
      proxy_pass          http://localhost:3000;
      proxy_read_timeout  90;

      proxy_redirect      http://localhost:3000 https://mydomain.com;
    }
}
#+end_example

The above will cause Nginx to redirect HTTP requests to HTTPS and use
the provided certificate to serve them.

Finally, configure your firewall to only allow access to specified ports
by running the following commands:

#+begin_example
$ sudo ufw allow ssh
$ sudo ufw allow http
$ sudo ufw allow https
$ sudo ufw enable
#+end_example

You can test the SSL configuration using the
[[https://www.ssllabs.com/ssltest/][SSL Server Test]].

** Heroku Deployment
:PROPERTIES:
:CUSTOM_ID: heroku-deployment
:END:
First, make sure you have [[http://git-scm.com/downloads][Git]] and
[[https://toolbelt.heroku.com/][Heroku toolbelt]] installed, then simply
follow the steps below.

Create a production configuration file in
=env/prod/resources/config.edn=. This file will provide base
configuration in Heroku environment.

#+begin_src clojure
{:prod true}
#+end_src

Optionally, test that your application runs locally:

#+begin_example
heroku local
#+end_example

Now, you can initialize your git repo and commit your application:

#+begin_example
git init
git add .
git commit -m "init"
#+end_example

Create your app on Heroku:

#+begin_example
heroku create
#+end_example

Optionally, create a database for the application:

#+begin_example
heroku addons:create heroku-postgresql
#+end_example

The connection settings can be found at your
[[https://dashboard.heroku.com/apps/][Heroku dashboard]] under the
add-ons for the app.

Deploy the application:

#+begin_example
git push heroku master
#+end_example

Your application should now be deployed to Heroku!

For further instructions see the
[[https://devcenter.heroku.com/articles/clojure][official
documentation]].

** Enabling Socket REPL
:PROPERTIES:
:CUSTOM_ID: enabling-socket-repl
:END:
Kit comes set up with a socket REPL, which allows connecting to a REPL
on the server. This functionality can useful for debugging as well as
hotfixing updates in the running application. To configure the REPL port
you can set the =REPL_PORT= environment variable to the desired port. By
default it is 7000.

#+begin_example
export REPL_PORT=7001
#+end_example

You can also connect your favorite IDE to a remote REPL just as you
would connect to a local one.

When running on a remote server it is recommended to forward the REPL
port to the local machine using SSH:

#+begin_example
ssh -L 7001:localhost:7001 remotehost
#+end_example

** Resources
:PROPERTIES:
:CUSTOM_ID: resources
:END:
- [[http://www.braveclojure.com/quests/deploy/][Deploying Your First
  Clojure App ...From the Shadows]] provides an indepth guide for
  Clojure web application deployment strategies.
